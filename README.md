# PainlessMesh
# ESP32 Bluetooth Bridge (Replaces HC-05)

У вас есть проект, к которому вы хотели бы иметь возможность подключиться
(и, возможно, перепрограммировать) другой микроконтроллер через Bluetooth, но
также хотели иметь возможность добавления нового Bluetooth, BLE или WIFIфункции? 
Ранее я использовал модуль Bluetooth HC-05 для обеспечения Bluetooth.
tty-доступ для взаимодействия и программирования. ESP32, однако, является всего лишь
немного дороже и предоставляет множество функций, которые HC-05 не может предложить, 
включая то, что его можно запрограммировать по беспроводной сети для
очень легко добавления своих собственных функции и возможностей.

Этот репозиторий содержит простой мост Bluetooth-UART.
повторяет поведение HC-05, но добавляет несколько новых функций:

* Escape-последовательность выхода, позволяющая вам вырваться из последовательного моста.
   для отправки команд непосредственно на само беспроводное устройство.
* Возможность принимать команды, в том числе позволяющую контролировать
   мост Bluetooth через UART1 ESP32.
* Настраиваемые контакты для:
     * Индикация подключения клиента через Bluetooth (`PIN_CONNECTED`)
     * Разрешение основному микроконтроллеру отправлять команды непосредственно на
       ESP32 («BT_KEY»).
     * Подключение к линии сброса микроконтроллера для отладки,
       перепрошивка и устранение неполадок.
     * Выходные контакты RX/TX для подключения к микроконтроллеру.
* Разнообразие команд (частично специфичных для STM32) и возможность
   добавить свои собственные команды.

## Commands

### `flash_esp32`

Эта команда запускает OTA-прошивку самого блока ESP32. В общем,
вам не нужно запускать эту команду напрямую, вместо этого используйте команду
включил скрипт Python в `programming/ota_flash.py` для прошивки ESP32
устройство через Bluetooth. Подробности см. в разделе «Прошивка ESP32 по воздуху».

### `flash_uc`

Эта команда предназначена для перезагрузки микроконтроллера STM32 в его
последовательный загрузчик от:

* Поднятие высокого уровня на вывод BOOT0 (см. `PIN_CONNECTED` в `main.h`)
* Подтягивание линии nRST к низкому уровню на 250 мс (см. `UC_NRST` в `main.h`)
* Подтягивание линии nRST к высокому уровню

В этот момент микроконтроллер будет готов принять программирование.
через блютуз.

### `reset_uc`

На короткое время подает низкий уровень на линию сброса микроконтроллера, чтобы вызвать его перезапуск.

### `boot0 [0|1]`

* При вызове без аргумента: возвращает текущее состояние вывода BOOT0.
(т. е. «PIN_CONNECTED»).
* При вызове с аргументом `0`: устанавливает на BOOT0 (`PIN_CONNECTED`) низкий уровень.
* При вызове с аргументом `1`: поднимает BOOT0 (`PIN_CONNECTED`) на высокий уровень.

PIN_CONNECTED обычно подключается непосредственно к выводу BOOT0 устройства.
микроконтроллер для эмуляции процедуры, исторически использовавшейся для использования
Блок HC-05 для прошивки микроконтроллера STM32. Вы заметите, что они
используются взаимозаменяемо в этом документе и в исходном коде, но
знайте, что вы можете регулировать состояние этого контакта независимо от его
поведение по умолчанию, указывающее, подключен ли клиент.

### `monitor [0|1]`

* При вызове без аргумента: возвращает текущее состояние монитора последовательного порта.
* При вызове с аргументом `0`: отключает последовательный мониторинг.
* При вызове с аргументом `1`: включает последовательный мониторинг.

Обратите внимание, это,  полезно только в том случае, если вы выводите команды
на UART1 устройства ESP32 вместо связи через Bluetooth.

### `nrst [0|1]`

* При вызове без аргумента: останавливает установку состояния
   вывод nRST микроконтроллера путем перенастройки соответствующего ESP32.
   контакт в качестве входа.
* При вызове с аргументом `0`: устанавливает низкий уровень nRST (`UC_NRST`).
* При вызове с аргументом `1`: поднимает nRST (`UC_NRST`) на высокий уровень.

### `unescape`

Выход из «экранированного» режима, если устройство ранее получило
соответствующую escape-последовательность. Это полезно, поскольку позволяет вам
повторно включить сквозную функциональность после выдачи escape-последовательности
чтобы отправить микроконтроллеру команду.

## Building the firmware

Сначала убедитесь, что у вас установлен компилятор xtensa.
(`xtensa-esp32-elf-gcc`) и что он доступен по вашему PATH.

Далее убедитесь, что вы клонировали все необходимые подмодули:

```
git submodule update --init --recursive
```

После этого установите переменную среды `IDF_PATH`.
указать на свой клон esp32 IDF (https://github.com/espressif/esp-idf) –
и убедитесь, что вы извлекли коммит, совместимый с
используемая версия arduino-esp32. Если вы используете этот репозиторий
как и сейчас, этот коммит должен быть `aaf12390`.
Теперь просто попросите его скомпилировать:

```
make
```

Теперь вы готовы установить эту прошивку на устройство. Обратите внимание: если вы
прошиваете по воздуху, следует выполнить процедуру, описанную ниже
в разделе «Прошивка ESP32 по воздуху» вместо обычной
процедура `сделать прошивку`.

## Escape Sequence

*Default*: `CTRL+D`, `CTRL+D`, `CTRL+D`, `!`

Клавиши escape-последовательности должны быть нажаты с интервалом не менее 500 мс.
другая (и, очевидно, никакие другие клавиши не могут быть нажаты между каждым из ваших
байты escape-последовательности). Это может показаться немного странным, но это
поведение существует как способ убедиться, что байты, передаваемые как
часть вашей escape-последовательности не возникает естественным образом как часть
некоторые другие данные, которые вы намеренно передаете на свой микроконтроллер.

Если вы хотите внести изменения в это поведение, см.:

* `main.h`: `BT_CTRL_ESCAPE_SEQUENCE_INTERCHARACTER_DELAY` корректировать
   минимальное количество времени, которое должно пройти между каждым персонажем вашего
   последовательность выхода.
* `main.cpp`; `BT_CTRL_ESCAPE_SEQUENCE` настроить саму escape-последовательность.


## Flashing the ESP32 Over-the-air

Само устройство ESP32 можно прошить через Bluetooth,
используя прилагаемый скрипт Python (`programming/ota_flash.py`); чтобы сделать это,
следуйте инструкциям ниже.

Обратите внимание, что перепрошивка практически на 100% безопасна для модуля ESP32; тот
встроенная в устройство функция беспроводного программирования умно
разработан и не переключится на вновь запрограммированный источник, если он не
проходит процедуру проверки. Если процесс перепрошивки не удался ни для одного
По этой причине установленный код останется неизменным.

### Building the firmware

See "Building the firmware".

### Installing Dependencies

From your clone of this repository, run the following commands:

```
cd programming
virtualenv . --python=python3
source bin/activate
pip install -r requirements.txt
cd ..
```

### Flashing the firmware

From your clone of this repository, run the following commands:

```
cd programming
python ota_flash.py /path/to/bluetooth/device
```

По умолчанию это будет:

* Подключитесь к указанному вами устройству (после этого вы
   быть подключен через проходное соединение к подключенному микроконтроллеру).
* Отправляет упомянутую выше «Escape-последовательность», чтобы избежать прохождения.
* Выдает команду `flash_esp32`.
* Ожидает готовности модуля ESP32.
* Отправляет новую прошивку, хранящуюся в `../build/bridge.bin`.
* Печатает все сообщения, полученные от устройства ESP32 во время этого процесса.

В конце этого процесса вы должны увидеть одно из следующих сообщений:

* `<completed: success>`: Если процесс перепрошивки завершился успешно.
* `<completed: failure>`: Если процесс перепрошивки по каким-то причинам не удался.
  Ознакомьтесь с другими отображаемыми сообщениями, чтобы определить потенциальную причину.
   причину неисправности прошивки. Обратите внимание, что сбои совершенно безопасны, и
   Вы можете попробовать перепрошить снова, как только захотите.

See `python ota_flash.py --help` for other options.
